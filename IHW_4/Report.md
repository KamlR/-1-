# Вариант 14

### Условие задачи
Задача о гостинице - 3 (дамы и джентльмены). В гостинице 10 номеров рассчитаны на одного человека и 15 номеров рассчитаны на двух человек. В гостиницу случайно приходят клиенты дамы и клиенты джентльмены,
и конечно они могут провести ночь в номере только с представителем своего
пола. Если для клиента не находится подходящего номера, он уходит искать
ночлег в другое место. Клиенты порождаются динамически и уничтожаются
при освобождении номера или уходе из гостиницы при невозможности поселиться. Создать многопоточное приложение, моделирующее работу гостиницы.

Задание выполнено на 10 баллов, далее я пройдусь по каждому критерию и дам к нему комментарий.

## Немного про использование программы:
- пользователь может считать данные из консоли, из файла, сгенерировать их (ниже про это ещё будет указано в соот. пункте)
- результат работы программы выводится как в консоль, так и в файл, поэтому какой бы вариант ввода вы не выбрали - нужно указывать файл для записи данных
- консоль - в качестве аргументов командной строки передать (формат ввода + имя файла для записи) console o.txt
- чтение из файла - в качестве аргументов командной строки передать (формат ввода + файл для чтения + файл для записи) file i.txt o.txt, при считывании данных из файла первым числом в файле идёт кол-во гостей (кол-во элементов массива)
- рандомные данные - в качестве аргументов командной строки передать (формат ввода + имя файла для записи) generate o.txt
## Файлы:
- в файле mutex_code лежит код, где в качестве синхропримитивов используются мьютексы
- в файле semaphore_code лежит код, где в качестве синхропримитивов используются семафоры
- в файле tests лежат тесты, по отдельности для каждой из двух ОС и отдельно для мьютексов и семафоров

## Ну что ж, поехали

### Критерии на 4 балла:
#### :white_check_mark: *Приведено условие задачи.*
- См.выше
#### :white_check_mark: *Описана модель параллельных вычислений, используемая при разработке многопоточной программы*
- В своей программе я использовала "Итеративный параллелизм". В задаче требуется реализовать работу гостиницы. Сейчас я кратко опишу, как я это делала. Я решила сделать два ресепшена (два потока), к каждому из которых подходят гости, которые хотят заселиться в гостиницу. Данные о гостях получаются либо из файла, либо из консоли, либо генерируются, как решит пользователь. Сами гости хранятся в массиве (guests), его я разделила на две части, одна часть гостей идёт на 1 ресепшен, другая на 2. Там они пытаются заселиться. В рамках параллельного программирования это выглдяит след. образом. Первая часть массива гостей обрабатывается в цикле 1 потоком, вторая часть массива обрабатывается втором потоком. Таким образом два потока работают над одной задачей - заселение гостей.
#### :white_check_mark: *Описаны входные данные программы, включающие вариативные диапазоны, возможные при многократных запусках.*
- Входные данные - это гости, которые затем помещаются в массив. Причём 0 - дамы, 1 - джентльмены.
#### :white_check_mark: *Реализовано консольное приложение, решающее поставленную задачу с использованием одного варианта синхропримитивов.*
- В качестве синхропримитивов я использовала mutex
#### :white_check_mark: *Ввод данных в приложение реализован с консоли*
- Пользоветель может выбрать способ ввода данных: консоль, генерация, чтение из файла

### Критерии на 5 балла:
#### :white_check_mark: *В программу добавлены комментарии, поясняющие выполняемые действия и описание используемых переменных.*
- Метод, который используется параллельно прокомментирован более подробно
#### :white_check_mark: *В отчете должен быть приведен сценарий, описывающий одновременное поведение представленных в условии задания сущностей в терминах предметной области. То есть, описано поведение объектов разрабатываемой программы как взаимодействующих субъектов, а не то, как это будет реализовано в программе.*
- Если рассматривать программу с точки зрения жизни, то ситуация следующая. Есть гости, которые приходят в отель, причём они подходят к разным ресепшенам, чтобы не создавать очередь. Гость говорит, какой он хочет номер. Далее сотрудники проверяют, возможно ли данный номер выдать гостю. Если да, то его заселяют, если нет, то отказывают. В роли гостей выступает массив, из которого я читаю данные. В роли номеров тоже выступают массивы, для одноместных и двуместных своё хранилище. Если заселена женщина, то это 0, если мужчина, то один.

### Критерии на 6 баллов:
#### :white_check_mark: *В отчете подробно описан обобщенный алгоритм, используемый при реализации программы исходного словесного сценария. В котором показано, как на программу отображается каждый из субъектов предметной области.*
- В  моей программе имеется массив с гостями (женщины-0, мужчины-1). Так же имеются массивы для одноместных и двухместных номеров. Если какой-то из номеров пуст или пуст частично (в случае с двухместным), то на в ячейке хранится -1 для данного номера. Причём роль двухместного номера выполняют два массива (для 1 и 2 человека). Есть метод settling - заселение, который выполняется параллельно. Первый поток обрабатывает первую часть массива гостей, а второй - вторую. Как это происходит? Для гостя генерируется номер, в которой он хотел бы заселиться (одноместный или двухместный). Далее проверяется, есть ли пустой номер, если да, то заселяем гостя. Для двухместных номеров такая же ситуация, только ещё учитывается, что мужчина и женщина вместе не заселились в двухместный номер. Также есть метод выселения гостей. В нём генерируется вид номера, из которого выселится человек. Если в массиве под этим номером кто-то живёт, то выселяем, иначе ничего не делаем. Причём секции, где происходит потенциальное заселение, т.е элемент -1 может замениться на 0 или 1, используются mutex, чтобы исключить неверной обработки данных. Выселение гостей тоже обёрнуто в mutex. Пользователю выводятся сообщения о том, кто заселился, кто выселился, а кому вообще не нашли номер.
#### :white_check_mark: *Реализован ввод данных из командной строки*
- Через командную строку у пользователя есть возможность указать, как он хочет ввести данные: консоль, генерация случайных данных, чтение из файла. В зависимости от желаемого ввода данных после имени программы указать: "console", "generate", "file " соотв. Причём данные всегда будут выводится в консоль, и в файл. Поэтому после типа ввода нужно указать имя файла для записи. Если выбрано чтение данных из файла, то ещё должно быть указано имя файла для чтения.

### Критерии на 7 баллов:
#### :white_check_mark: *В программу добавлены ввод данных из файла и вывод результатов в файл.*
- Ввод данных из файла можно указать при запуске (см. на 6 баллов описание), в файл всегда пишутся данные, не зависит от формата ввода данных.
#### :white_check_mark: *Приведены входные и выходные файлы с различными результатами выполнения программы.*
- См. в папке tests
- Я тестировла свою программу на windows и Linux и заметила одну особенность. При запуске программы на Linux потоки отрабатывали последовательно, например, в начале только второй, а потом только 1 или наоборот. При запуске на Windows они постоянно менялись, то 1,то 2. Это хорошо видно в тестах, которые я приложила. Там есть отдельно тесты для Windows и Linux. (1_i.txt - input, 1_o.txt-output, так для каждых пяти тестов). reception 1 - первый поток, reception 2 - второй поток.
#### :white_check_mark: *Результаты работы программы должны выводиться на экран и записываться в файл.*
- Есть
### Критерии на 8 баллов:
#### :white_check_mark: *В программу добавлена генерация случайных данных в допустимых диапазонах.*
- Допускается генерация массива гостей, как его размер, так и сами гости, причём размер массива будет сген. от 10 до 50
Далее тоже выполнено на 8
### Критерии на 9 баллов:
Для начала ещё раз напомню, что в своей программе в качестве синхропримитивов я использвую мьютексы, благодаря которым к определённой секции кода имеет доступ только один поток, т.е только один поток может в неё зайти.
Где конкретно я использую мьютексы:
- заселение в одноместный номер
- заселение в двухметсный номер
- выселение пользователя

В программе видно, что потоки могут совершенно спокойно запрашивать генерацию для желаемого номера пользователя, вместе заселять в отдельно одноместный и двухместный номера, но вместе обращаться к данным одних и тех номеров они не могут.
Теперь будем разбираться, что может произойти, если убрать мьютексы. Например, я разрешу ситуацию, при которой два потока смогут одновремено заселять в одноместные номера. В таком случае может возникунуть следующая ситуация. Предположим, что у нас имеется некая свободная комната под ноимером два, след. в данной ячейке, как было сказано ранее хранится -1. Первому и второму потоку может попасться ситуация, когда обоим сгенерировалась ситуация, при которой гость хочет заселиться в одноместный номер. Пусть первый поток начал искать свободное место и наткнулся на вторую комнату, она свободна, значит можно заселить. Второй поток в это же время проверил эту комнату, она тоже оказалась свободной, так как 1  ещё не успел туда что-то записать. По итогу получится так, что один поток затрёт данные другого и запишет свою информацию. В реальной жизни это можно описать так: двух гостей по вышеописанной ошибке заселили в один номер. Они к нему вдвоём подходят и начинают спорить, кто прав, а кто виноват. Да, конечно по итогу номер будет числиться за кем-то одним, так как один поток просто перезапишет данные другого. Но вопрос в том, что на моменте проверке свободных номеров обоим сказаали, что они свободны и выдали ключ, так как один из потоков зашёл на прооверку, пока другой ещё нне успел заселить человека. С двухместными номерами может возникнуть такая же проблема с перезаписью владельца номера.

Если говорить о некорретных данных, то здесь вряд ли можно утверждать, что они вообще есть. Скорее просто могут возникать ситуации, при которых оба потока будут хотеть заселить в одинаковые номера. Вот если бы первый поток мог заселять только в одноместные, а второй только в двухместные, то проблем бы вообще не было, так как они работали бы с разными массивами данных. В нашем же случае некорректное поведение может возникать, когда в обоих потоках гость захочет заселиться либо в одноместный, либо в двухместный номер.

### Критерии на 10 баллов:
#### :white_check_mark: *Разработано альтернативное решение, построенное на других синхропримитивах.*
- Новое решение построено на использовании семафоров
- Файл с этим кодом лежит в папке code, в файле threads_semaphores
#### :white_check_mark: *Приведен сравнительный анализ поведения с ранее разработанной программой.*
- Основное различие естественно различается в том, что используются разные синхропримитивы
- Теперь хотелось бы рассказать, в чём конкретно данное различие заключается
Когда мы используем мьютексы, то только один поток может заходить в критическую секцию, которая обёрнута в мьютекс.
При использовании семафоров мы можем указывать при инициализации, сколько конкретно потоков может заходить в критическую секцию одновременно.
У меня 3 параметром при инициализации указана 1, так как в моей программе в крит. секцию может зайти только один поток. Как это работает? У семафора есть счётчик, который считает кол-во поток, зашедших в критическую секцию. Как только счётчик становится равен числу, которое мы указали при инициализации - доступ к секции другим потокам блокируется. Когда какой-то поток выходит - счётчик уменьшается на 1 => другие потоки опять могут заходить. 

В моей программе предпочтительнее использовать именно мьютексы, так как у меня только один поток может заходить в крит. секцию, иначе возникнет ошибка, описанная ранее. Но в качестве альтернативы я решила показать, что семафоры тоже помогут организовать блокировку секций кода.

Если говорить о поведении программы с мьютексами и семафорами, то я не могу сказать, что заметила какую-то разницу.
