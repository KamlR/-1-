# Вариант 11
### Условие задачи
Разработать программу вычисления отдельно количества гласных и согласных букв в ASCII-строке.
## Про оформление
Моя работа выполнена на 9 баллов, в своём отчёте я пройдусь по каждому пункту критериев, начиная от 4 баллов до 9 баллов.
- в папке asm лежат прокоммментированные файлы на ассемблере скомпелированные с флагами gcc 
- в папке asm_no_opt лежат файлы на ассемблере без оптимизации
- в папке asm_regs лежат  прокоммментированные файлы на ассемблере, где используются регистры процессора вместо переменных на стеке
- в папке size_opt лежат файлы на ассемблере, оптимизированные по размеру
- в папке speed_opt лежат файлы на ассемблере, оптимизированные по скорости
- в папке ci лежат файлы с кодом на си
- в папке tests лежат тесты

# Ну что ж, начнём
## Критерии на 4 балла:
#### :white_check_mark: *Приведено решение задачи на C*
- его можно найти в приложенных файлах (папка ci)
#### :white_check_mark: *В полученную ассемблерную программу, откомпилированную без оптимизирующих и отладочных опций, добавлены комментарии, поясняющие эквивалентное представление переменных в программе на C.*
- код на ассемблере и его комментирование можно найти в файлах с расширением .s
#### :white_check_mark: *Из ассемблерной программы убраны лишние макросы за счет использования соответствующих аргументов командной строки и/или за счет ручного редактирования исходного текста ассемблерной программы.*
- Программа откомпилирована при помощи флагов gcc

    gcc -masm=intel \
    -fno-asynchronous-unwind-tables \
    -fno-jump-tables \
    -fno-stack-protector \
    -fno-exceptions \
    ./code.c \
    -S -o ./code.s
#### :white_check_mark: *Модифицированная ассемблерная программа отдельно откомпилирована и скомпонована без использования опций отладки.*
- имеются исполняемые файлы
#### :white_check_mark: *Представлено полное тестовое покрытие, дающее одинаковый результат на обоих программах. Приведены результаты тестовых прогонов для обоих программ, демонстрирующие эквивалентность функционирования.*
- про тесты будет сказано ниже (они есть)

## Критерии на 5 баллов:
#### :white_check_mark: *В реализованной программе необходимо использовать функции с передачей данных через параметры.*
- такие функции есть. Например, передача имён файлов для ввода и вывода данных в work_with_file.s
#### :white_check_mark: *Использовать локальные переменные.*
- используются, например, count_vowels и count_consonants(кол-во гласных и согласных) в work_with_file.s и generate_choice.s
#### :white_check_mark: *В ассемблерную программу при вызове функции добавить комментарии, описывающие передачу фактических параметров и перенос возвращаемого результата.*
- при вызове функций в коде ассемблера указано, в каких регистрах лежат передаваемые занчения
- также даны комментарии, в каком регистре лежит какое возвращаемое значение
#### :white_check_mark: *В функциях для формальных параметров добавить комментарии, описывающие связь между параметрами языка Си и регистрами (стеком)*

## Критерии на 6 баллов:
#### :white_check_mark: *Рефакторинг программы на ассемблере за счет оптимизации использования регистров процессора. Или написание ассемблерной программы с нуля, используя собственное распределение регистров.*
- в main.s rbp[-4](argc) -> r12d (4 байта)
- в work_with_file.s -> rbp[-40](размер строки в файле) -> r12 (8 байт), rbp[-4](кол-во гласных) -> r13d, rbp[-8](кол-во согласн.) -> r14d
- в generate_choice.s rbp[-20](длина строки) -> r12d, rbp[-4](кол-во гласных) -> r13d, rbp[-8](кол-во согласн.) -> r14d
#### :white_check_mark: *Добавление комментариев в разработанную программу, поясняющих эквивалентное использование регистров вместо переменных исходной программы на C.*
- комментирование для данного пункта хранится в папке asm_regs
#### :white_check_mark: *Представление результатов тестовых прогонов для разработанной программы. Оценка корректности ее выполнения на основе сравнения тестовых прогонов результатами тестирования программы, разработанной на языке C.*
#### :white_check_mark: *Сопоставление размеров программы на ассемблере, полученной после компиляции с языка C с модифицированной программой, использующей регистры.*
- потом вернусь

## Критерии на 7 баллов:
#### :white_check_mark: *Реализация программы на ассемблере в виде двух или более единиц компиляции (программу на языке C разделять допускается, но не обязательно).*
- имеется три единицы компиляции: main.s, work_with_file.s и generate_choice.s
#### :white_check_mark: *Использование файлов с исходными данными и файлов для вывода результатов. Имена файлов задаются с использованием аргументов командной строки. Командная строка проверяется на корректность числа аргументов и корректное открытие файлов.*
- через командную строку можно передать названия файлов для ввода и вывода данных
- есть проверка на кол-во аргументов командной строки, если их кол-во = 0, то выводится строка с ошибкой "Incorrect input" и программа завершается
- в методах work_with_file.s есть проверка на корректность открытия файла, если ошибка, то выводится строка "Problems with file" и программа завершается

## Критерии на 8 баллов:
#### :white_check_mark: *Использование в разрабатываемых программах генератора случайных наборов данных, расширяющих возможности тестирования*
- В программе есть возможность сгенерирвовать случайную строку длиной от 1 до 100 символов
#### :white_check_mark: *Изменение формата командной строки с учетом выбора ввода из файлов или с использованием генератора.*
- при запуске пользователь может ввести выбрать, как он хочет тестировать данные: читать из файлов или же сгенерировать строку
- если после ./test.exe(пример запуска) введена одна любая строка (без пробелов), то это будет вызван метод генерации случайной строки
- если после ./test.exe(пример запуска) введены две строки, то вызовется метод чтения и записи в файл
#### :white_check_mark: *Пункт про замеры времени*
- независимо от выбора ввода данных (файл или генерация) будет проведён замер времени работы алгоритма
- пользовтелю в конце работы программы выводится строка "Algorithm operation time: время работы в наносекундах"
#### :white_check_mark: *Представить полученные временные данные в отчете для разных вариантов тестовых прогонов (наряду с другими данными, полученные при выполнении ранее описанных требований).*
- Время работы алгоритмов будет приведено ниже (на скриншотах будет видна строка "Algorithm operation time: время на наносекундах")

## Критерии на 9 баллов:
#### :white_check_mark: *Используя опции оптимизации по скорости, сформировать из программы на на C исходный код ассемблере. Провести сравнительный анализ с ассемблерной программой без оптимизации по размеру ассемблерного кода, размеру исполняемого файла и производительности. Сопоставить эти программы с собственной программой, разработанной на ассемблере, в которой вместо переменных максимально возможно используются регистры.*
- для получения файлов, оптимизированных по скорости я использовала флаг -O3
- для получения файлов, оптимизированных по размеру я использовала флаг -Os
##### Беру три разных программы:
*Для сравнения производительности я взяла строку ниже и посмотрела время работы алгоритмов в наносекундах*

xi0w#{Mg.[O7!GY,|R=rciDDuQzq'a# H0tK)C17{]N|&(& WCp8+5\!fUrj7rh\ Z&'}7>wtjtzo{xH?i`G~;Hbp9M%)3a*n
- Файлы из папки asm_no_opt (без оптимизаций):
  - main.s - 121 строка, work_with_file.s - 218 строк, generate_choice - 204 строки
  - размер исполняемого файла - 16,8 кБ (16 768 байт)
  - время работы - 3918
- Файлы из папки speed_opt (оптимизированные по скорости)
  - main.s - 88 строк, work_with_file.s - 238 строк, generate_choice - 211 строк
  - размер исполняемого файла - 16,8 кБ (16 800 байт)
  - 2214
- Файлы из папки size_opt (опитизированные по размеру)
  - main.s - 64 строки, work_with_file.s - 199 строк, generate_choice - 156 строк
  - размер исполняемого файла - 16,7 кБ (16 728 байт)
  - 2277
- Файлы из папки asm_regs (моя программа с использованием регистров процессора)
  - main.s - 87 строк, work_with_file.s - 184 строк, generate_choice - 170 строк
  - размер исполняемого файла - 16,6 кБ (16 640 байт)
  - 4006
  
##### Подведу итоги:
1) Если сравнивать файл оптимизированный по скорости, не оптимизированный вообще и мой собственный, то
    - размер ассемблерного кода меньше всего в моём собственном
    - размер исполняемого файла меньше всего в моём собственном
    - быстрее всего отработал оптимизированный по скорости
2) Если сравнивать файл оптимизированный по размеру, не оптимизированный вообще и мой собственный, то
    - размер ассемблерного кода меньше всего в файле оптимизированным по размеру
    - размер исполняемого файла меньше всего в моём собственном
    - быстрее всего отработал оптимизированный по размеру
    
    
### Теперь тестовые прогоны
Их я буду делать с программой, где используются регистры процессора и кодом на си
- Как я буду это делать?
    - перехожу в директрию с кодом си (cd ci)
    - генерирую рандомную строку (./all.exe g), на месте может быть любая строка без пробелов, так как 1 стока == вызов метода генерации
    - записываю получившуюся строку в i.txt (nano i.txt)
    - проверяю, что правда записала то, что нужно (cat i.txt)
    - выполняю программу с чтением из файла (./all.exe i.txt o.txt)
    - смотрю результат (cat o.txt)
    - перехожу в директорию с программой на ассемб. ( cd ../   cd asm_regs)
    - записываю текущую строку в i.txt (nano i.txt)
    - проверяю, что правда записала то, что нужно (cat i.txt)
    - выполняю программу с чтением из файла (./all.exe i.txt o.txt)
    - смотрю результат (cat o.txt)
    - в конце сравниваю все ответы
 
 1) Таким образом проверю сразу и работу с генератором, и работу с файлом.
 2) Если в консоли я нахожусь в папке ci, то работаю с сишным кодом (all.exe), если в asm_regs, то моя программа (asm_regs.exe)
 3) Первые 4 теста я буду начинать с кода на си (генерацию), последние 4 с кода на ассемблере, чтобы показать, что генерация тоже работает везде.
 4) Я прикреплю скрины результатов, 8 файликов с тестами будут лежать в папке tests
 
 #### Для начала покажу работу на некорректных данных:
 ![image](https://user-images.githubusercontent.com/115434090/201492382-9e8e93a2-1526-4302-af10-e321b098a736.png)
 
 Видно, что если вводится некорректное число аргументов, то обе программы выводят "Incorrect input"
 
 Если возникает проблема с файлами, то выводится "Problems with file"

#### Первый тест:
![image](https://user-images.githubusercontent.com/115434090/201492677-504c2585-111d-40fc-98b7-8d1547bd8119.png)

Ответы одинаковые, всё хорошо

#### Второй тест:
![image](https://user-images.githubusercontent.com/115434090/201492884-6282f848-7ce4-45f3-809a-d3df7155bead.png)

Сошлось

#### Третий тест:
![image](https://user-images.githubusercontent.com/115434090/201493062-2ff8a347-566a-4f0f-8920-9993c401495b.png)

Сошлось

#### Четвёртый тест:
![image](https://user-images.githubusercontent.com/115434090/201493405-2c36d4ac-c41b-473b-8402-03888e62e1fe.png)

Сошлось

Теперь начинаю генерацию с кода на ассемблере

#### Пятый тест:
![image](https://user-images.githubusercontent.com/115434090/201493557-c7fc8ee9-b29f-4aec-996e-fd7c7563e07c.png)

Сошлось

#### Шестой тест:
![image](https://user-images.githubusercontent.com/115434090/201493689-132551b6-15c9-4a4a-b47d-866f757ad3b6.png)

Сошлось

#### Седьмой тест:
![image](https://user-images.githubusercontent.com/115434090/201493801-f4a2d4cc-a87f-4d53-89ba-3400237e099c.png)

Сошлось

#### Восьмой тест:
![image](https://user-images.githubusercontent.com/115434090/201493988-702a2bbd-99f0-419a-bb5f-3fa64e5a74e7.png)

Сошлось
